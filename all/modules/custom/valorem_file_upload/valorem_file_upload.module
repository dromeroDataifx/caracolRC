<?php

/**
 * Implementation of hook_menu().
 */
function valorem_file_upload_menu() {
  $items = array();
  
  $items['admin/config/user-interface/batch_file_upload'] = array(
    'title' => t('Importar listado PUC'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('valorem_file_upload_import'),
    'access callback' => TRUE,
    'weight' => 12,
    'type' => MENU_NORMAL_ITEM,
  );
  return $items;
}

/**
 * Generates the file import form.
 */
function valorem_file_upload_import() {
  $form = array('#attributes' => array('enctype' => 'multipart/form-data'));
  $form['source'] = array('#type' => 'fieldset', '#title' => t('Source'));
  $form['source']['upload'] = array(
      '#type' => 'file',
      '#title' => t('file'),
  );
  if ($max_size = _valorem_file_upload_parse_size(ini_get('upload_max_filesize'))) {
      $form['source']['upload']['#description'] = t('Due to server restrictions, the maximum upload file size is !size. Files that exceed this size will be disregarded without notice.', array('!size' => format_size($max_size)));
  }
  $form['source']['delimiter'] = array(
    '#type' => 'select',
    '#title' => t('file delimiter'),
    '#options' => array(
        '#comma' => t('Comma – default'),
        '#semicolon' => t('Semicolon – Microsoft Excel'),
    ),
    '#description' => t('Choose the delimiter used in the file you want to import.'),
  );
  $form['submit'] = array('#type' => 'submit', '#value' => t('Update'));
  return $form;
}
/**
 * Parses PHP configuration size values into bytes.
 *
 * Edited from an example at http://php.net/manual/en/function.ini-get.php
 */
function _valorem_file_upload_parse_size($value) {
  $value = trim($value);
  $number = (int) drupal_substr($value, 0, -1);
  $suffix = drupal_strtoupper(drupal_substr($value, -1));
  switch ($suffix) {
      case 'G':
          $number *= 1024;
      case 'M':
          $number *= 1024;
      case 'K':
          $number *= 1024;
  }
  return $number;
}

/**
 * Handles file import form validation.
 */
function valorem_file_upload_import_validate($form, &$form_state) {
    $form_state['upload_file'] = file_save_upload('upload', array('file_validate_extensions' => array(0 => 'csv')));
    if (!$form_state['upload_file']) {
        form_set_error('upload', t('Please upload a file.'));
    } else {
        $form_state['upload_file']->filepath = drupal_realpath($form_state['upload_file']->uri);
    }
}

/**
 * Handles file import form submission.
 */
function valorem_file_upload_import_submit($form, &$form_state) {
    valorem_file_upload_import_batch($form, $form_state);
}

/**
 * Batch operation.
 * Used for validation and saving
 */
function valorem_file_upload_import_batch($form, &$form_state) {
    $file = $form_state['upload_file'];
    $options = $form_state['values'];
    if ($options['delimiter'] == "semicolon") {
        $delimiter = ';';
    } else {
        $delimiter = ',';
    }

    // Automatically detect line endings.
    ini_set('auto_detect_line_endings', '1');
    $handle = fopen($file->filepath, 'r');
    $first = TRUE;

    $operations = array();

    while ($line = fgetcsv($handle, 4096, $delimiter)) {
      if (empty($line) || (count($line) == 1 && $line[0] == NULL))
          continue;
      // Skip UTF-8 byte order mark.
      if ($first) {
        if (strncmp($line[0], "\xEF\xBB\xBF", 3) === 0)
            $line[0] = drupal_substr($line[0], 3);
        $first = FALSE;
      }
      else {
        // Convert line to UTF-8.
        $line = array_map('_valorem_file_upload_import_line_to_utf8', $line);
        $operations[] = array('_valorem_file_upload_batch', array($line));
        //valorem_file_upload_leer_linea($line);
      }
    }
    $batch = array(
    'operations' => $operations,
    'finished' => '_valorem_file_upload_finished',
    );
    batch_set($batch);
    fclose($handle);
}

function _valorem_file_upload_batch($line, &$context) {
  $context['message'] = t('PUC ', array('@title' => '')) . ' ' . $line[0] . ' - ' . $line[1];
  
  // NIVEL 1 (clases)    
  if (Strlen($line[0]) == 1) {
    $term = _term(2, $line[1], $line[0], _nivel(1), '');
    taxonomy_term_save($term);
  }

   // NIVEL 2 (grupos)
  if (Strlen($line[0]) == 2) {
    $query = db_select('field_data_field_codigo_puc', 'c')
      ->fields('c');
    $result = $query->execute();
    while($record = $result->fetchAssoc()) {
      if (substr($line[0], 0,1) == $record['field_codigo_puc_value']) {
        $term = _term(2, $line[1], $line[0], _nivel(2), $record['entity_id']);
        taxonomy_term_save($term);
      }
    }    
  }

   // NIVEL 3 (cuentas)
  if (Strlen($line[0]) == 4) {
    $query = db_select('field_data_field_codigo_puc', 'c')
      ->fields('c');
    $result = $query->execute();
    while($record = $result->fetchAssoc()) {
      if (substr($line[0], 0,2) == $record['field_codigo_puc_value']) {
        $term = _term(2, $line[1], $line[0], _nivel(4), $record['entity_id']);
        taxonomy_term_save($term);
      }
    }    
  }

   // NIVEL 4 (subcuentas)
  if (Strlen($line[0]) == 6) {
    $operations[] = array('_valorem_file_upload_batch', array($line[0] . ' - ' . $line[1]));
    $query = db_select('field_data_field_codigo_puc', 'c')
      ->fields('c');
    $result = $query->execute();
    while($record = $result->fetchAssoc()) {
      if (substr($line[0], 0,4) == $record['field_codigo_puc_value']) {
        $term = _term(2, $line[1], $line[0], _nivel(6), $record['entity_id']);
        taxonomy_term_save($term);
      }
    }    
  }
}

/**
 *  construccion del termino de taxonomia
 */
function _term($vid, $name, $puc, $nivel, $parent) {
  $term = new stdClass(); 
  $term->vid = $vid;
  $term->name = $name;
  $term->field_codigo_puc['und'][0]['value'] = $puc;
  $term->field_nivel['und'][0]['value'] = $nivel;
  if ($parent != '') {
    $term->parent = $parent; 
  }
  return $term;
}

/**
 *  retorna nivel del puc
 */
function _nivel($chr) {
  $nivel = 0;
  switch ($chr) {
    case '1':
      $nivel = 1;
      break;
    case '2':
      $nivel = 2;
      break;
    case '4':
      $nivel = 3;
      break;
    case '6':
      $nivel = 4;
      break;
  }
  return $nivel;
}

/**
 * Helper function to convert each line item to UTF-8.
 */
function _valorem_file_upload_import_line_to_utf8($value) {
    $enc = mb_detect_encoding($value, "UTF-8, ISO-8859-1, ISO-8859-15", TRUE);
    if ($enc != "UTF-8") {
        $value = drupal_convert_to_utf8($value, $enc);
    }
    return $value;
}

/**
 * Helper function to get the term id of a term in a vocabulary.
 *
 * @param $terms
 *   Term that you want the tid from.
 * @param $vid
 *   Vocabulary ID that you want the term to match to.
 * @param $type
 *   (optional) The node type for which the term(s) will apply.
 *
 * @return
 *   Term ID of the term if one matches, FALSE otherwise.
 */
function _i_file_get_correct_term(&$array, $terms, $vid, $type = NULL) {
  $vocabs = taxonomy_get_vocabularies($type);
  $vocab = $vocabs[$vid];
  switch (TRUE) {
      // Tags option
    case $vocab->tags:
      $array['tags'][$vid] = $terms;
      break;

    // Multiple select option
    case $vocab->multiple:
        // Split the input
      $terms_split = preg_split('/(,)(?=(?:[^"]|"[^"]*")*$)/', $terms);
      foreach ($terms_split as &$term) {
          // remove initial/ending -white spaces- and -"- from terms
          $term = trim($term, ' "');
      }
      // Remove reference
      unset($term);

      // Get the vocab tree
      $tree = taxonomy_get_tree($vid);
      $form = array();
      // Go through the tree
      foreach ($tree as $term) {
          // Check if the term was submitted
          $key = array_search($term->name, $terms_split);
          // If it was submitted set the form to its -nid- value
          // Unset the term form the original array
          if ($key !== FALSE) {
              $form[$term->tid] = $term->tid;
              unset($terms_split[$key]);
          }
          // If not submitted, set its value tu NULL
          else {
              $form[$term->tid] = NULL;
          }
      }
      // If nothing left in the array, means terms submitted were correct
      // We break here
      if (empty($terms_split)) {
          $array[$vid] = $form;
          break;
      }
      // if something was left, then FALSE.
      $array[$vid] = FALSE;
      break;

    // Single select option
    default:
    // Get all posible matches
      $terms = taxonomy_get_term_by_name($terms);
      // Check which one belongs to out vocab
      foreach ($terms as $term) {
          // If it belongs, set the value and -break 2-
          if ($term->vid == $vid) {
              $array[$vid] = $term->tid;
              break 2;
          }
      }
    // Still here? We didn't find a match
    // Set value to FALSE
      $array[$vid] = FALSE;
    break;
  }
}

/**
 * Batch operation for batch 1: load a node.
 * This is the function that is called on each operation in batch 1.
 */
/*function _valorem_file_upload_batch($operation_details, &$context) {
  $context['message'] = t('PUC ', array('@title' => '')) . ' ' . $operation_details;
}*/

/**
 * Batch 'finished' callback used by both batch 1 and batch 2.
 */
function _valorem_file_upload_finished($success, $results, $operations) {
    if ($success) {
    drupal_set_message(t('Termino correcamente', array('%final' => end($results))));
    drupal_goto('admin/structure/taxonomy_manager/voc/puc');
  }
  else {
    $error_operation = reset($operations);
    drupal_set_message(t('An error occurred while processing @operation with arguments : @args', array('@operation' => $error_operation[0], '@args' => print_r($error_operation[0], TRUE))));
  }
}